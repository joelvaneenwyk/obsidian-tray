/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// main.ts
var obsidian = __toESM(require("obsidian"));
var electron = __toESM(require("electron"));
var import_main = require("electron/main");
var import_common = require("electron/common");
var import_electron = require("electron");
var LOG_PREFIX = "obsidian-tray";
var LOG_LOADING = "loading";
var LOG_CLEANUP = "cleaning up";
var LOG_SHOWING_WINDOWS = "showing windows";
var LOG_HIDING_WINDOWS = "hiding windows";
var LOG_WINDOW_CLOSE = "intercepting window close";
var LOG_TRAY_ICON = "creating tray icon";
var LOG_REGISTER_HOTKEY = "registering hotkey";
var LOG_UNREGISTER_HOTKEY = "unregistering hotkey";
var ACTION_QUICK_NOTE = "Quick Note";
var ACTION_SHOW = "Show Vault";
var ACTION_HIDE = "Hide Vault";
var ACTION_RELAUNCH = "Relaunch Obsidian";
var ACTION_CLOSE = "Close Vault";
var DEFAULT_DATE_FORMAT = "YYYY-MM-DD";
var ACCELERATOR_FORMAT = `
    This hotkey is registered globally and will be detected even if Obsidian does
    not have keyboard focus. Format:
    <a href="https://www.electronjs.org/docs/latest/api/accelerator" target="_blank" rel="noopener">
    Electron accelerator</a>
  `;
var MOMENT_FORMAT = `
    Format:
    <a href="https://momentjs.com/docs/#/displaying/format/" target="_blank" rel="noopener">
    Moment.js format string</a>
  `;
var OBSIDIAN_BASE64_ICON = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHZSURBVDhPlZKxTxRBFMa/XZcF7nIG7mjxjoRCwomJxgsFdhaASqzQxFDzB1AQKgstLGxIiBQGJBpiCCGx8h+wgYaGgAWNd0dyHofeEYVwt/PmOTMZV9aDIL/s5pvZvPfN9yaL/+HR3eXcypta0m4juFbP5GHuXc9IbunDFc9db/G81/ZzhDMN7g8td47mll4R5BfHwZN4LOaA+fHa259PbUmIYzWkt3e2NZNo3/V9v1vvU6kkstk+tLW3ItUVr/m+c3N8MlkwxYqmBFcbwUQQCNOcyVzDwEAWjuPi5DhAMV/tKOYPX5hCyz8Gz1zX5SmWjBvZfmTSaRBJkGAIoxJHv+pVW2yIGNxOJ8bUVNcFEWLxuG1ia6JercTbttwQTeDwPS0kCMXiXtgk/jQrFUw7ptYSMWApF40yo/ytjHq98fdk3ayVE+cn2CxMb6ruz9qAJKFUKoWza1VJSi/n0+ffgYHdWW2gHuxXymg0gjCB0sjpmiaDnkL3RzDyzLqBUKns2ztQqUR0fk2TwSrGSf1eczqF5vsPZRCQSSAFLk6gqctgQRkc6TWRQLV2YMYQki9OoNkqzFQ9r+WOGuW5CrJbOzyAlPKr6MSGLbkcDwbf35oY/jRkt6cAfgNwowruAMz9AgAAAABJRU5ErkJggg==`;
var log = (message) => console.log(`${LOG_PREFIX}: ${message}`);
var tray;
var plugin;
var childWindows = /* @__PURE__ */ new Set();
var observeChildWindows = () => {
  electron.remote.getCurrentWindow().webContents.on("did-create-window", (win) => {
    childWindows.add(win);
    win.on("close", () => childWindows.delete(win));
    win.setSkipTaskbar(plugin.settings.hideTaskbarIcon);
  });
};
var getAllWindows = () => [...childWindows, getCurrentWindow()];
var showWindows = () => {
  log(LOG_SHOWING_WINDOWS);
  getAllWindows().forEach((win) => win.show());
};
var hideWindows = () => {
  log(LOG_HIDING_WINDOWS);
  getAllWindows().forEach((win) => [
    win.isFocused() && win.blur(),
    plugin.settings.runInBackground ? win.hide() : win.minimize()
  ]);
};
var toggleWindows = (checkForFocus = true) => {
  const openWindows = getAllWindows().some((win) => {
    return (!checkForFocus || win.isFocused()) && win.isVisible();
  });
  if (openWindows)
    hideWindows();
  else
    showWindows();
};
var onWindowClose = (event) => event.preventDefault();
var onWindowUnload = (event) => {
  log(LOG_WINDOW_CLOSE);
  getCurrentWindow().hide();
  event.stopImmediatePropagation();
  event.returnValue = false;
};
var interceptWindowClose = () => {
  window.addEventListener("beforeunload", onWindowUnload, true);
  getCurrentWindow().on("close", onWindowClose);
};
var allowWindowClose = () => {
  getCurrentWindow().removeListener("close", onWindowClose);
  window.removeEventListener("beforeunload", onWindowUnload, true);
};
var setHideTaskbarIcon = () => {
  getAllWindows().forEach((win) => {
    win.setSkipTaskbar(plugin.settings.hideTaskbarIcon);
  });
};
var setLaunchOnStartup = () => {
  const { launchOnStartup, runInBackground, hideOnLaunch } = plugin.settings;
  import_electron.app.setLoginItemSettings({
    openAtLogin: launchOnStartup,
    openAsHidden: runInBackground && hideOnLaunch
  });
};
var relaunchApp = () => {
  import_electron.app.relaunch();
  import_electron.app.exit(0);
};
var closeVault = () => {
  log(LOG_CLEANUP);
  unregisterHotkeys();
  allowWindowClose();
  destroyTray();
  getAllWindows().forEach((win) => win.destroy());
};
var addQuickNote = () => {
  const { quickNoteLocation, quickNoteDateFormat } = plugin.settings, pattern = quickNoteDateFormat || DEFAULT_DATE_FORMAT, date = obsidian.moment().format(pattern), name = obsidian.normalizePath(`${quickNoteLocation != null ? quickNoteLocation : ""}/${date}`).replace(/\*|"|\\|<|>|:|\||\?/g, "-");
  plugin.app.fileManager.createAndOpenMarkdownFile(name);
  showWindows();
};
var replaceVaultName = (str) => {
  return str.replace(/{{vault}}/g, plugin.app.vault.getName());
};
var destroyTray = () => {
  tray == null ? void 0 : tray.destroy();
};
var createTrayIcon = () => {
  var _a;
  destroyTray();
  if (!plugin.settings.createTrayIcon)
    return;
  log(LOG_TRAY_ICON);
  const obsidianIcon = import_common.nativeImage.createFromDataURL(
    (_a = plugin.settings.trayIconImage) != null ? _a : OBSIDIAN_BASE64_ICON
  ), contextMenu = import_main.Menu.buildFromTemplate([
    {
      type: "normal",
      label: ACTION_QUICK_NOTE,
      accelerator: plugin.settings.quickNoteHotkey,
      click: addQuickNote
    },
    {
      type: "normal",
      label: ACTION_SHOW,
      accelerator: plugin.settings.toggleWindowFocusHotkey,
      click: showWindows
    },
    {
      type: "normal",
      label: ACTION_HIDE,
      accelerator: plugin.settings.toggleWindowFocusHotkey,
      click: hideWindows
    },
    { type: "separator" },
    { label: ACTION_RELAUNCH, click: relaunchApp },
    { label: ACTION_CLOSE, click: closeVault }
  ]);
  tray = new import_main.Tray(obsidianIcon);
  tray.setContextMenu(contextMenu);
  tray.setToolTip(replaceVaultName(plugin.settings.trayIconTooltip));
  tray.on("click", () => toggleWindows(false));
};
var registerHotkeys = () => {
  log(LOG_REGISTER_HOTKEY);
  try {
    const { toggleWindowFocusHotkey, quickNoteHotkey } = plugin.settings;
    if (toggleWindowFocusHotkey) {
      import_electron.globalShortcut.register(toggleWindowFocusHotkey, toggleWindows);
    }
    if (quickNoteHotkey) {
      import_electron.globalShortcut.register(quickNoteHotkey, addQuickNote);
    }
  } catch (e) {
    console.warn("Failed to register hotkeys");
  }
};
var unregisterHotkeys = () => {
  log(LOG_UNREGISTER_HOTKEY);
  try {
    import_electron.globalShortcut.unregister(plugin.settings.toggleWindowFocusHotkey);
    import_electron.globalShortcut.unregister(plugin.settings.quickNoteHotkey);
  } catch (e) {
    console.warn("Failed to register hotkeys");
  }
};
var OPTIONS = [
  "Window management",
  {
    key: "launchOnStartup",
    desc: "Open Obsidian automatically whenever you log into your computer.",
    type: "toggle",
    default: false,
    onChange: setLaunchOnStartup
  },
  {
    key: "hideOnLaunch",
    desc: `
      Minimises Obsidian automatically whenever the app is launched. If the
      "Run in background" option is enabled, windows will be hidden to the system
      tray/menubar instead of minimised to the taskbar/dock.
    `,
    type: "toggle",
    default: false
  },
  {
    key: "runInBackground",
    desc: `
      Hides the app and continues to run it in the background instead of quitting
      it when pressing the window close button or toggle focus hotkey.
    `,
    type: "toggle",
    default: false,
    onChange() {
      setLaunchOnStartup();
      const runInBackground = plugin.settings.runInBackground;
      if (!runInBackground)
        showWindows();
    }
  },
  {
    key: "hideTaskbarIcon",
    desc: `
      Hides the window's icon from from the dock/taskbar. Enabling the tray icon first
      is recommended if using this option. This may not work on Linux-based OSes.
    `,
    type: "toggle",
    default: false,
    onChange: setHideTaskbarIcon
  },
  {
    key: "createTrayIcon",
    desc: `
      Adds an icon to your system tray/menubar to bring hidden Obsidian windows
      back into focus on click or force a full quit/relaunch of the app through
      the right-click menu.
    `,
    type: "toggle",
    default: true,
    onChange: createTrayIcon
  },
  {
    key: "trayIconImage",
    desc: `
      Set the image used by the tray/menubar icon. Recommended size: 16x16
      <br>Preview: <img data-preview style="height: 16px; vertical-align: bottom;">
    `,
    type: "image",
    default: OBSIDIAN_BASE64_ICON,
    onChange: createTrayIcon
  },
  {
    key: "trayIconTooltip",
    desc: `
      Set a title to identify the tray/menubar icon by. The
      <code>{{vault}}</code> placeholder will be replaced by the vault name.
      <br>Preview: <b class="u-pop" data-preview></b>
    `,
    type: "text",
    default: "{{vault}} | Obsidian",
    postprocessor: replaceVaultName,
    onChange: createTrayIcon
  },
  {
    key: "toggleWindowFocusHotkey",
    desc: ACCELERATOR_FORMAT,
    type: "hotkey",
    default: "CmdOrCtrl+Shift+Tab",
    onBeforeChange: unregisterHotkeys,
    onChange: registerHotkeys
  },
  "Quick notes",
  {
    key: "quickNoteLocation",
    desc: "New quick notes will be placed in this folder.",
    type: "text",
    placeholder: "Example: notes/quick"
  },
  {
    key: "quickNoteDateFormat",
    desc: `
      New quick notes will use a filename of this pattern. ${MOMENT_FORMAT}
      <br>Preview: <b class="u-pop" data-preview></b>
    `,
    type: "moment",
    default: DEFAULT_DATE_FORMAT
  },
  {
    key: "quickNoteHotkey",
    desc: ACCELERATOR_FORMAT,
    type: "hotkey",
    default: "CmdOrCtrl+Shift+Q",
    onBeforeChange: unregisterHotkeys,
    onChange: registerHotkeys
  }
];
var keyToLabel = (key) => key[0].toUpperCase() + key.slice(1).split(/(?=[A-Z])/).map((word) => word.toLowerCase()).join(" ");
var htmlToFragment = (html) => document.createRange().createContextualFragment((html != null ? html : "").replace(/\s+/g, " "));
var SettingsTab = class extends obsidian.PluginSettingTab {
  display() {
    var _a, _b, _c;
    this.containerEl.empty();
    for (const opt of OPTIONS) {
      const setting = new obsidian.Setting(this.containerEl);
      if (typeof opt === "string") {
        setting.setName(opt);
        setting.setHeading();
      } else {
        if (opt.default)
          (_a = opt.placeholder) != null ? _a : opt.placeholder = `Example: ${opt.default}`;
        setting.setName(keyToLabel(opt.key));
        setting.setDesc(htmlToFragment(opt.desc));
        const onChange = async (value2) => {
          var _a2, _b2;
          await ((_a2 = opt.onBeforeChange) == null ? void 0 : _a2.call(opt));
          plugin.settings[opt.key] = value2;
          await plugin.saveSettings();
          await ((_b2 = opt.onChange) == null ? void 0 : _b2.call(opt));
        };
        const value = (_c = (_b = plugin.settings[opt.key]) != null ? _b : opt.default) != null ? _c : "";
        if (opt.type === "toggle") {
          setting.addToggle((toggle) => {
            toggle.setValue(value).onChange(onChange);
          });
        } else if (opt.type === "image") {
          const previewImg = setting.descEl.querySelector("img[data-preview");
          if (previewImg)
            previewImg.src = value;
          const fileUpload = setting.descEl.createEl("input");
          fileUpload.style.visibility = "hidden";
          fileUpload.type = "file";
          fileUpload.onchange = (event) => {
            if (event.target != null) {
              const file = event.target.files[0], reader = new FileReader();
              reader.onloadend = () => {
                onChange(reader.result);
                if (previewImg)
                  previewImg.src = reader.result;
              };
              reader.readAsDataURL(file);
            }
          };
          setting.addButton((button) => {
            button.setIcon("image").onClick(() => fileUpload.click());
          });
        } else if (opt.type === "moment") {
          setting.addMomentFormat((moment2) => {
            var _a2;
            const previewEl = setting.descEl.querySelector("[data-preview]");
            if (previewEl)
              moment2.setSampleEl(previewEl);
            moment2.setPlaceholder(opt.placeholder).setDefaultFormat((_a2 = opt.default) != null ? _a2 : "").setValue(value).onChange(onChange);
          });
        } else {
          const previewEl = setting.descEl.querySelector("[data-preview]"), updatePreview = (value2) => {
            var _a2;
            if (!previewEl)
              return;
            previewEl.innerText = (_a2 = opt == null ? void 0 : opt.postprocessor(value2)) != null ? _a2 : value2;
          };
          updatePreview(value);
          setting.addText((text) => {
            text.setPlaceholder(opt.placeholder).setValue(value).onChange((value2) => [onChange(value2), updatePreview(value2)]);
          });
        }
      }
    }
  }
};
var TrayPlugin = class extends obsidian.Plugin {
  TrayPlugin() {
    this.settings = this;
  }
  async onload() {
    log(LOG_LOADING);
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    const { settings } = this;
    plugin = this;
    createTrayIcon();
    registerHotkeys();
    setHideTaskbarIcon();
    setLaunchOnStartup();
    observeChildWindows();
    if (settings.runInBackground)
      interceptWindowClose();
    if (settings.hideOnLaunch) {
      this.registerEvent(this.app.workspace.onLayoutReady(hideWindows));
    }
    this.addCommand({
      id: "relaunch-app",
      name: ACTION_RELAUNCH,
      callback: relaunchApp
    });
    this.addCommand({
      id: "close-vault",
      name: ACTION_CLOSE,
      callback: closeVault
    });
  }
  onunload() {
    log(LOG_CLEANUP);
    unregisterHotkeys();
    allowWindowClose();
    destroyTray();
  }
  async loadSettings() {
    const DEFAULT_SETTINGS = OPTIONS.map((opt) => ({
      // @ts-ignore
      [opt.key]: opt.default
    }));
    this.settings = Object.assign(...DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
module.exports = TrayPlugin;
